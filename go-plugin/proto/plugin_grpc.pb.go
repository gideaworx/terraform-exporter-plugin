// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: plugin.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ExportCommandClient is the client API for ExportCommand service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExportCommandClient interface {
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error)
	Info(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CommandInfo, error)
	Help(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SingleString, error)
}

type exportCommandClient struct {
	cc grpc.ClientConnInterface
}

func NewExportCommandClient(cc grpc.ClientConnInterface) ExportCommandClient {
	return &exportCommandClient{cc}
}

func (c *exportCommandClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error) {
	out := new(ExportResponse)
	err := c.cc.Invoke(ctx, "/proto.ExportCommand/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exportCommandClient) Info(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CommandInfo, error) {
	out := new(CommandInfo)
	err := c.cc.Invoke(ctx, "/proto.ExportCommand/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exportCommandClient) Help(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SingleString, error) {
	out := new(SingleString)
	err := c.cc.Invoke(ctx, "/proto.ExportCommand/Help", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExportCommandServer is the server API for ExportCommand service.
// All implementations must embed UnimplementedExportCommandServer
// for forward compatibility
type ExportCommandServer interface {
	Export(context.Context, *ExportRequest) (*ExportResponse, error)
	Info(context.Context, *Empty) (*CommandInfo, error)
	Help(context.Context, *Empty) (*SingleString, error)
	mustEmbedUnimplementedExportCommandServer()
}

// UnimplementedExportCommandServer must be embedded to have forward compatible implementations.
type UnimplementedExportCommandServer struct {
}

func (UnimplementedExportCommandServer) Export(context.Context, *ExportRequest) (*ExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Export not implemented")
}
func (UnimplementedExportCommandServer) Info(context.Context, *Empty) (*CommandInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedExportCommandServer) Help(context.Context, *Empty) (*SingleString, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Help not implemented")
}
func (UnimplementedExportCommandServer) mustEmbedUnimplementedExportCommandServer() {}

// UnsafeExportCommandServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExportCommandServer will
// result in compilation errors.
type UnsafeExportCommandServer interface {
	mustEmbedUnimplementedExportCommandServer()
}

func RegisterExportCommandServer(s grpc.ServiceRegistrar, srv ExportCommandServer) {
	s.RegisterService(&ExportCommand_ServiceDesc, srv)
}

func _ExportCommand_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExportCommandServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ExportCommand/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExportCommandServer).Export(ctx, req.(*ExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExportCommand_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExportCommandServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ExportCommand/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExportCommandServer).Info(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExportCommand_Help_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExportCommandServer).Help(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ExportCommand/Help",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExportCommandServer).Help(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ExportCommand_ServiceDesc is the grpc.ServiceDesc for ExportCommand service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExportCommand_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ExportCommand",
	HandlerType: (*ExportCommandServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Export",
			Handler:    _ExportCommand_Export_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _ExportCommand_Info_Handler,
		},
		{
			MethodName: "Help",
			Handler:    _ExportCommand_Help_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}

// ExportPluginClient is the client API for ExportPlugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExportPluginClient interface {
	Export(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ExportResponse, error)
	Info(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginInfo, error)
}

type exportPluginClient struct {
	cc grpc.ClientConnInterface
}

func NewExportPluginClient(cc grpc.ClientConnInterface) ExportPluginClient {
	return &exportPluginClient{cc}
}

func (c *exportPluginClient) Export(ctx context.Context, in *PluginRequest, opts ...grpc.CallOption) (*ExportResponse, error) {
	out := new(ExportResponse)
	err := c.cc.Invoke(ctx, "/proto.ExportPlugin/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exportPluginClient) Info(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PluginInfo, error) {
	out := new(PluginInfo)
	err := c.cc.Invoke(ctx, "/proto.ExportPlugin/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExportPluginServer is the server API for ExportPlugin service.
// All implementations must embed UnimplementedExportPluginServer
// for forward compatibility
type ExportPluginServer interface {
	Export(context.Context, *PluginRequest) (*ExportResponse, error)
	Info(context.Context, *Empty) (*PluginInfo, error)
	mustEmbedUnimplementedExportPluginServer()
}

// UnimplementedExportPluginServer must be embedded to have forward compatible implementations.
type UnimplementedExportPluginServer struct {
}

func (UnimplementedExportPluginServer) Export(context.Context, *PluginRequest) (*ExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Export not implemented")
}
func (UnimplementedExportPluginServer) Info(context.Context, *Empty) (*PluginInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedExportPluginServer) mustEmbedUnimplementedExportPluginServer() {}

// UnsafeExportPluginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExportPluginServer will
// result in compilation errors.
type UnsafeExportPluginServer interface {
	mustEmbedUnimplementedExportPluginServer()
}

func RegisterExportPluginServer(s grpc.ServiceRegistrar, srv ExportPluginServer) {
	s.RegisterService(&ExportPlugin_ServiceDesc, srv)
}

func _ExportPlugin_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExportPluginServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ExportPlugin/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExportPluginServer).Export(ctx, req.(*PluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExportPlugin_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExportPluginServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ExportPlugin/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExportPluginServer).Info(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ExportPlugin_ServiceDesc is the grpc.ServiceDesc for ExportPlugin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExportPlugin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ExportPlugin",
	HandlerType: (*ExportPluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Export",
			Handler:    _ExportPlugin_Export_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _ExportPlugin_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin.proto",
}
